import math
from tkinter import *
import time

INPUT_TURN_LEFT     = 0
INPUT_TURN_RIGHT    = 1
INPUT_ACCELERATE    = 2
INPUT_FIRE          = 3 
INPUT_NO_ACTION     = 5

HEIGHT = 800
WIDTH = 1000


class Player:

    ROTATION_STEP = math.pi/11.25
    SPEED_MAX     = 6 

    def __init__(self,x,y):
        self.x        = x 
        self.y        = y 
        self.speed_x  = 0.0
        self.speed_y  = 0.0
        self.rotation = 0.0
        self.size     = 15
        self.ixState  = 0
        self.mass = 1000

    def step(self, action):
        self.handleAction(action)
        self.updateLocation()
        if self.ixState == 1:
            self.ixState = 0
    
    def updateLocation(self):
        self.x = self.x + self.speed_x
        self.y = self.y + self.speed_y

    def handleAction(self, action):
        if action==INPUT_TURN_LEFT:
            self.rotation -= self.ROTATION_STEP
        elif action==INPUT_TURN_RIGHT:
            self.rotation += self.ROTATION_STEP
        elif action == INPUT_FIRE:
            print("fire")
        elif action == INPUT_ACCELERATE:
            x_s = self.speed_x + math.cos(self.rotation)*1
            y_s = self.speed_y + math.sin(self.rotation)*1
            self.setSpeed(x_s, y_s)

    def setSpeed(self, x_s, y_s):
        ns = math.sqrt(x_s**2 + y_s**2) 
        if ns < self.SPEED_MAX:
            self.speed_x = x_s
            self.speed_y = y_s
        else:
            norm = self.SPEED_MAX / ns;
            self.speed_x = x_s * norm;
            self.speed_y = y_s * norm;


class Collisions:
    def checkWallCollision(self, obj):
        if(obj.x + obj.speed_x + obj.size > WIDTH):
            obj.speed_x*=-1
        elif(obj.x + obj.speed_x - obj.size < 0):
            obj.speed_x*=-1
        elif(obj.y + obj.speed_y + obj.size > HEIGHT):
            obj.speed_y*=-1
        elif(obj.y + obj.speed_y - obj.size < 0):
            obj.speed_y*=-1
    
    def checkCollision(self, obj1, obj2):
        if self.getDistance(obj1, obj2) < (obj1.size + obj2.size):
            if obj2.ixState == 0: 
                obj1.setSpeed(obj1.speed_x + self.calcDXSpeed(obj1, obj2), obj1.speed_y + self.calcDYSpeed(obj1, obj2))
                obj2.setSpeed(obj2.speed_x + self.calcDXSpeed(obj2, obj1), obj2.speed_y + self.calcDYSpeed(obj2, obj1))
                print("speed change")
            obj2.ixState = 2
        
        else:
            obj2.ixState = 1
          

    def calcDXSpeed(self, obj1, obj2):
        return (obj1.speed_x * (obj1.mass - obj2.mass) + (2 * obj2.mass * obj2.speed_x)) / (obj1.mass + obj2.mass) 

    def calcDYSpeed(self, obj1, obj2):
        return (obj1.speed_y * (obj1.mass - obj2.mass) + (2 * obj2.mass * obj2.speed_y)) / (obj1.mass + obj2.mass) 
             
    def getDistance(self, obj1, obj2):
        return math.sqrt((obj1.x + obj1.speed_x - obj2.x + obj2.speed_x)**2 + (obj1.y + obj1.speed_y - obj2.y + obj2.speed_y)**2)


        
        
class DefBox:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class Ball:

    SPEED_MAX = 7 

    def __init__(self, x, y, speed_x, speed_y):
        self.x = x
        self.y = y
        self.size = 10
        self.speed_x = speed_x 
        self.speed_y = speed_y
        self.ixState = 0
        self.mass = 5
    
    def step(self):
        self.updateLocation()
        if self.ixState == 1:
            self.ixState = 0
    
    def updateLocation(self):
        self.x = self.x + self.speed_x
        self.y = self.y + self.speed_y
    
    def setSpeed(self, x_s, y_s):
        ns = math.sqrt(x_s**2 + y_s**2) 
        if ns < self.SPEED_MAX:
            self.speed_x = x_s
            self.speed_y = y_s
        else:
            norm = self.SPEED_MAX / ns;
            self.speed_x = x_s * norm;
            self.speed_y = y_s * norm;


class Goal:
    def __init__(self, x, y)


class Game:

    def __init__(self, useUI = False):
        self.useUI = useUI
        self.player1 = Player(50, 50)
        self.player1DefBox = DefBox(300, 400);
        self.player2DefBox = DefBox(700, 400);
        self.balls = self.createBalls() 
        self.col = Collisions()

        if self.useUI:
            self.UI = UI()


    def createBalls(self):

        ball1 = Ball(100, 100, 1.0, 0.0)
        ball2 = Ball(700, 600, -1.0, 0.0)
        ball3 = Ball(500, 100, 0.0, 1.0)

        return list([ball1, ball2, ball3])
    
    def step(self, action):
        self.col.checkWallCollision(self.player1)
        
        for ball in self.balls:
            self.col.checkWallCollision(ball)
            self.col.checkCollision(self.player1, ball)
        
        self.player1.step(self.getPlayer1Action());

        for ball in self.balls:
            ball.step()


        if self.useUI:
            self.UI.update(self);
    
    def getPlayer1Action(self):
        return self.UI.getPlayerAction();

class UI:

    def __init__(self):
        self.tk = Tk()
        self.tk.bind("<KeyPress>", self.keypress)
        self.tk.bind("<KeyRelease>", self.keyup)
        self.canvas = Canvas(self.tk, width=1000, height=800) 
        self.canvas.pack()
        self.action = INPUT_NO_ACTION
    
    def keypress(self, e):
        if(e.keycode == 87):
            self.action = INPUT_ACCELERATE
        elif(e.keycode == 65):
            self.action = INPUT_TURN_LEFT
        elif(e.keycode == 68):
            self.action = INPUT_TURN_RIGHT
    
    def keyup(self, e):
        if(e.keycode == 87 or e.keycode == 65 or e.keycode == 68):
            self.action = INPUT_NO_ACTION
            

    def getPlayerAction(self):
        a = self.action;
        return a;

    def update(self, game):

        self.canvas.delete("all")
        self.canvas.create_oval(game.player1.x-game.player1.size, game.player1.y-game.player1.size, game.player1.x + game.player1.size , game.player1.y+game.player1.size, width=2, fill='blue')
        self.canvas.create_line(game.player1.x, game.player1.y, game.player1.x + math.cos(game.player1.rotation)*game.player1.size, game.player1.y + math.sin(game.player1.rotation)*game.player1.size, width=3)

        for ball in game.balls:
            self.canvas.create_oval(ball.x-ball.size, ball.y-ball.size, ball.x+ball.size, ball.y+ball.size)


        time.sleep(0.01)
        self.tk.update();
        
############ not game logic code ################

game = Game(useUI = True)
while(True):
    game.step(2);









